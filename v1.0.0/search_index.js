var documenterSearchIndex = {"docs":
[{"location":"#functions-1","page":"-","title":"functions","text":"","category":"section"},{"location":"#","page":"-","title":"-","text":"expanded_size\ncollapsed_size\nexpand_labels\nstandardize_labels\nunstandardize_labels\ntrain\ninfer\nquad_coeff_matrix","category":"page"},{"location":"#TheCannon.expanded_size","page":"-","title":"TheCannon.expanded_size","text":"expandeded_size(nlabels; quadratic=true)\n\nThe length of a label vector of length nlabels after it has been  quadratically expanded.\n\nSee also: collapsed_size\n\n\n\n\n\n","category":"function"},{"location":"#TheCannon.collapsed_size","page":"-","title":"TheCannon.collapsed_size","text":"collapsed_size(nelabels; quadratic=true)\n\nThe length of a label vector corresponding to an expanded label  vector of length nelabels.\n\nSee also: expanded_size\n\n\n\n\n\n","category":"function"},{"location":"#TheCannon.expand_labels","page":"-","title":"TheCannon.expand_labels","text":"expand_labels(labels; quadratic=true)\n\nIf labels is a Vector, return it's quadratic (or linear) expansion. If labels is a Matrix, return the matrix whose rows are expansions of the rows of labels.\n\nThis is the transformation referred to as eta in Wheeler+ 2020, and as the \"vectorizing function\" in Casey+ 2016.\n\n\n\n\n\n","category":"function"},{"location":"#TheCannon.standardize_labels","page":"-","title":"TheCannon.standardize_labels","text":"Standardize the label matrix (nstars x nlabels) to live roughly in [-1, 1] by subtractive the mean and dividing by the scatter. returns (standardized_labels, pivots, scales)\n\n\n\n\n\n","category":"function"},{"location":"#TheCannon.unstandardize_labels","page":"-","title":"TheCannon.unstandardize_labels","text":"Transform labels back to their unstandardize form. Returns\n\nlabels.*transpose(hcat(scale)) .+ transpose(hcat(pivot))\n\n\n\n\n\n","category":"function"},{"location":"#TheCannon.train","page":"-","title":"TheCannon.train","text":"train(flux, ivar, labels, mask=nothing, verbose=true, quadratic=true)\n\nreturns: theta, scatters Run the training step of The Cannon, i.e. calculate coefficients for each pixel.\n\nflux contains the spectra for each star in the training set.  It should be   nstars x npixels (row-vectors are spectra)\nivar contains the inverse variance for each pixel in the same shape as flux\nlabels contains the labels for each star.  It should be nstars x nlabels.  It will be expanded into the quadratic label space before training.\nmask (optional) is a nlabels x npix matrix of booleans specifying which  labels are \"allowed\" to affect the spectrum at each pixel.\n\nreturns:\n\ntheta: the matrix containing the cannon coefficients.    It will be n_expanded_labels x npix\nscatters: the model scatter at each pixel\n\n\n\n\n\n","category":"function"},{"location":"#TheCannon.infer","page":"-","title":"TheCannon.infer","text":"infer(flux, ivar, theta, scatters; quadratic=true, verbose=true)\n\nRun the test step of the cannon.  Given theta and scatters (from training), infer stellar parameters.\n\nflux contains the spectra for each star for which you want to infer labels \n\nin the training set.  It should be nstars x npixels (row-vectors are spectra)\n\nivar contains the inverse variance for each pixel in the same shape as flux\ntheta: the matrix containing the cannon coefficients.  It will be n_expanded_labels x npix\nscatters: the model scatter at each pixel\n\nIf verbose is set to true, gives an update for every 100 stars processed.\n\n\n\n\n\n","category":"function"},{"location":"#TheCannon.quad_coeff_matrix","page":"-","title":"TheCannon.quad_coeff_matrix","text":"Get the quadratic terms of theta as symetric matrices. returns an array of dimensions nlabels x nlabels x npixels\n\nQ = quad_coeff_matrix(theta)\nQ[:, :, 1] #quadratic coefficients for first pixel\n\n\n\n\n\n","category":"function"}]
}
